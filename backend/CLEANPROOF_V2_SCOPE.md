# CleanProof V2 — Product & Architecture Scope

Документ описывает, **что такое V2 для CleanProof**, в чём он отличается от V1  
и какие направления развития считаются приоритетными.

Это **не техническая спецификация задач**, а опорный документ:  
по нему можно собирать PRD, бэклог и архитектурные решения.

---

## 0. Связь с V1

### V1 — что уже есть

На момент старта V2:

- execution-ядро **реально работает**:
  - Jobs: статусы `scheduled → in_progress → completed`;
  - GPS check-in / check-out + distance validation;
  - proof: before/after photos, checklist, audit trail через `JobCheckEvent`.
- SLA-слой функционирует:
  - issue rate, violations count;
  - top SLA reasons, топовые локации и клинеры.
- Reports:
  - weekly / monthly отчёты;
  - PDF-генерация;
  - email-рассылка;
  - Owner overview в UI как in-app dashboard.
- Evidence:
  - Reports → Violations → Jobs → Job details / JobSidePanel;
  - связка до реальных доказательств (фото, чек-лист, события).

V1 уже можно демить как работающий продукт.

### V2 — зачем нужен

V2 не про «больше экранов».  
**V2 = убираем ограничения V1, делаем продукт масштабируемым и удобным для сетей 50–100+ локаций.**

Основные цели V2:

1. Сделать execution слой устойчивым к реальным условиям (оффлайн, сбои, сложные политики).
2. Расширить SLA/Evidence так, чтобы можно было защищать решения перед владельцем/клиентом.
3. Вывести аналитику из “оперативных отчётов” в полноценный, но не перегруженный Analytics-слой.
4. Добавить коммерческий скелет (тарифы, лимиты, роли) без избыточной сложности.
5. Подготовить платформу к enterprise-клиентам через audit, versioning и согласованную модель данных.

---

## 1. Принципы V2

1. **Evolution, not rewrite**
   - Никаких «переписать всё с нуля».
   - V2 — надстройка над V1, максимально reuse существующих сущностей.

2. **Backend = source of truth**
   - Все правила, политики, расчёты — на стороне backend.
   - Frontend только отображает и оркестрирует UX.

3. **Один слой за раз**
   - Работы по V2 разбиваются по слоям (Execution / SLA / Analytics / Commerce / Platform).
   - В каждом слое: сначала закрываем минимальный вертикальный срез, потом расширяем.

4. **Ограничения лучше, чем хаос**
   - Лучше иметь меньше функций, но с ясной семантикой и предсказуемым поведением,
     чем “много галочек, но всё ведёт себя странно”.

5. **Analytics API определяет факты. SLA/Reports определяют интерпретацию.**
   - Analytics — источник метрик.
   - SLA и Reports — разные “линзы” на эти метрики для разных ролей.

---

## 2. Пилон V2.1 — Execution & Mobile (Offline-first, Proof Policies)

### 2.1. Цель

**Сделать выполнение работ устойчивым и предсказуемым даже при плохой связи,  
и не завязать всю архитектуру навсегда на текущий UX.**

Сегодня:
- мобильный клиент строго требует before/after и чек-лист;
- кнопка complete неактивна без proof;
- всё хорошо, пока есть сеть и UX не меняется.

Задача V2 — подготовиться к будущему, где:
- будет оффлайн;
- появится возможность “форснуть complete” из веба;
- для части задач фото могут быть опциональными.

### 2.2. Offline-first execution (минимальный, но реальный)

#### Семантика

Вводим явные состояния синхронизации для мобильных действий:

- `pending_sync` — событие создано на устройстве, не подтверждено сервером;
- `synced` — событие успешно записано на сервер;
- `sync_failed` — попытка отправки не удалась, нужен retry.

Эти состояния могут относиться к:

- check-in / check-out,
- загрузке фото,
- чек-листу,
- переводу job в `completed`.

#### Требования к UX

- Клинер **явно видит**, что:
  - job “ожидает отправки”,
  - всё синхронизировано,
  - есть ошибки и их можно повторить.
- Никаких “тихих фейлов”:
  - если фото не ушло — это видно,
  - если чек-лист не записался — это видно.

#### Требования к backend

- Возможность принимать события “задним числом” с метаданными:
  - `created_at` (на устройстве),
  - `received_at` (на сервере).
- Чёткие правила:
  - как считать фактическое время выполнения при оффлайне;
  - как разрешать конфликты, если одно и то же действие отправлено дважды.

---

### 2.3. Flexible proof policies

#### Проблема V1

Сейчас logic примерно:

> “Всегда нужны before & after & checklist”.

V2 должен позволить конфигурировать:

- где фото обязательны;
- где только after;
- где чек-лист обязателен;
- где достаточно одного фото.

#### Уровни политики

Минимум:

1. **На уровне компании**
   - глобальная политика по умолчанию:
     - required: before/after/checklist (true/false).

2. **На уровне локации**
   - переопределение политики:
     - “в этой локации достаточно after-only”.

3. **(Опционально позже) На уровне типа job**
   - например, deep clean vs regular cleaning.

#### Взаимодействие с SLA

- `missing_before_photo`, `missing_after_photo`, `checklist_not_completed`
  остаются **универсальными reason code**.
- Политика отвечает на вопрос:
  > “Считается ли отсутствие before-фото нарушением для этой job?”
- SLA engine должен учитывать:
  - policy для конкретной job;
  - фактические события (фото/чек-лист).

---

### 2.4. Mobile UX reliability

#### Задачи

1. Ясное состояние job:
   - не только `scheduled/in_progress/completed`,
   - но и:
     - “в процессе выгрузки”,
     - “нужны фото”,
     - “нужен чек-лист”.

2. Ошибки:
   - единый стиль сообщений;
   - минимизация технических формулировок;
   - явные кнопки “повторить” / “обновить”.

3. Валидация на клиенте:
   - не позволять отправлять пустые данные;
   - однако **все критичные проверки — на backend**, чтобы не было расхождений.


## 2.5. Checklist System v2 (Evolution of Execution Proof)

### Цель

**Превратить чек-лист из “обязательной галочки” в полноценный управляемый инструмент качества и SLA.**

В V1 чек-лист уже играет ключевую роль:

* он создаётся из шаблона при планировании job;
* участвует в proof-of-work;
* является прямой причиной SLA `checklist_not_completed`.

V2 должен:

* сохранить простоту базового сценария;
* снять ограничения V1;
* позволить масштабировать чек-листы под разные типы клиентов, локаций и задач.

---

### 2.5.1. Checklist templates v2 (управляемые и расширяемые)

#### Проблема V1

Сейчас:

* чек-лист — это список пунктов;
* все пункты по сути равны;
* нет формальной семантики, кроме required / not required.

Это работает для небольших команд,
но плохо масштабируется на 50–100+ локаций и разные типы работ.

#### Направление V2

Шаблон чек-листа становится **структурированным объектом**, а не просто массивом строк.

Минимальные расширения:

* пункт чек-листа может иметь:

  * `label` — текст пункта;
  * `required` — обязателен ли для completion;
  * `category` (опционально) — например: floors / bathroom / kitchen;
* шаблон может содержать:

  * `description` — зачем он используется;
  * `items_count`;
  * `version` (см. ниже).

Это позволяет:

* гибко управлять логикой completion;
* в будущем делать аналитику по категориям;
* не ломать существующие шаблоны.

---

### 2.5.2. Checklist versioning (критично для SLA и аудита)

#### Проблема

Если шаблон меняется со временем:

* какие пункты действовали **на момент выполнения job**?
* по какой версии чек-листа считать SLA?

#### Решение V2

* Каждый шаблон имеет `version`.
* При создании job:

  * версия шаблона **фиксируется**;
  * чек-лист job становится snapshot’ом.
* Изменения шаблона **не влияют** на уже созданные job.

Это критично для:

* SLA-споров;
* отчётов за прошлые периоды;
* enterprise-аудита.

---

### 2.5.3. Partial completion & checklist semantics

#### Проблема V1

Сейчас чек-лист либо:

* completed,
* либо нет.

Это бинарная модель.

#### Возможности V2

* считать completion:

  * по required-пунктам;
  * игнорируя optional;
* хранить:

  * `completed_items_count`;
  * `required_items_count`.

Это открывает:

* более честную аналитику качества;
* мягкие SLA-правила:

  * например, “95% required items completed”.

---

### 2.5.4. Checklist + Proof policies

Чек-лист в V2 должен быть частью **общей proof-политики**, а не отдельным миром.

Политика определяет:

* обязателен ли чек-лист для данной job;
* считается ли его отсутствие SLA-нарушением;
* можно ли завершить job без чек-листа (и при каких условиях).

Пример:

* Regular cleaning:

  * checklist required;
* Emergency cleaning:

  * checklist optional;
* Audit cleaning:

  * checklist + photos mandatory.

---

### 2.5.5. Analytics & quality insights (V2+)

После стабилизации Execution и SLA:

Чек-лист становится источником **качественной аналитики**, а не просто proof.

Примеры будущих метрик:

* % completed checklist per cleaner;
* самые часто пропускаемые пункты;
* проблемные зоны (bathroom / kitchen);
* корреляция checklist completion ↔ SLA violations.

Важно:

* аналитика строится **поверх данных**,
  без усложнения мобильного UX на ранних этапах.

---

### 2.5.6. Что осознанно НЕ делаем в V2

Чтобы сохранить фокус:

* ❌ произвольные чек-листы “на лету” от клинеров;
* ❌ сложные conditional-rules (“если пункт A — показать пункт B”);
* ❌ чек-листы как no-code workflow builder.

Это:

* либо V3,
* либо отдельный продуктовый слой.

---

### Роль чек-листа в V2 (резюме)

В V2 чек-лист:

* остаётся **частью execution-ядра**;
* становится **формализованным доказательством качества**;
* напрямую влияет на SLA и аналитику;
* масштабируется без переписывания V1.

---

## **2.6. Email History & Report Delivery (V2-ready Evidence Layer)**

### 2.6.1. Роль Email history в V2

В V1 email-отправка отчётов была побочным действием:

> «нажали кнопку — письмо ушло».

В V2 **Email history — это часть Evidence и Audit-слоя**, а не UI-фича.

Email history отвечает на вопросы:

* **что именно** было отправлено (job / weekly / monthly report);
* **когда** и **кому**;
* **кем инициировано** (manager / system);
* **доставлено или нет**;
* как это связано с конкретным job, периодом и SLA.

Таким образом, email становится:

* управляемым действием;
* доказательством коммуникации;
* объектом аудита.

---

### 2.6.2. Unified Email History (what already exists)

На момент старта V2 уже реализован базовый слой:

* единый лог отправки отчётов:

  * job reports;
  * weekly reports;
  * monthly reports;
* единый backend-эндпоинт:

  * `GET /api/manager/report-emails/`;
* серверная фильтрация:

  * по дате **фактической отправки** (`created_at`);
  * по типу отчёта;
  * по статусу (`sent / failed`);
  * по job / email получателя;
* серверная пагинация;
* manager-facing UI:

  * Reports → Email history;
  * таблица + фильтры + empty state.

Это уже делает Email history **первоклассным Evidence-объектом**, а не техническим логом.

---

### 2.6.3. Email history как часть Evidence & SLA

В V2 Email history рассматривается как:

* **доказательство коммуникации** с владельцем / клиентом;
* дополнительный сигнал при SLA-разборе:

  * отчёт отправлен вовремя;
  * отчёт не отправлен;
  * отчёт не доставлен.

Примеры интерпретаций (не reason code, а бизнес-смысл):

* job выполнен, но отчёт **не отправлен** → процессный gap;
* отчёт отправлен, но **failed** → техническая проблема;
* отчёт отправлен повторно → признак инцидента или спора.

Важно:
Email history **не генерирует SLA violation напрямую**,
но может быть использован как **контекст и аргумент**.

---

### 2.6.4. Delivery semantics (V2)

В V2 вводится чёткая семантика доставки отчётов:

Каждая отправка фиксирует:

* `kind` — job / weekly / monthly;
* `context` — job_id или период;
* `sent_at` — момент отправки;
* `delivery_status`:

  * `sent` — письмо принято почтовым провайдером;
  * `failed` — ошибка отправки;
* `error_reason` (если failed);
* `sent_by` — пользователь или system action.

Это позволяет:

* анализировать надёжность доставки;
* строить audit trail;
* готовиться к enterprise-требованиям.

---

### 2.6.5. Email delivery v2 (future extensions)

После стабилизации базового слоя V2 допускает расширения:

**Retry & resend**

* повторная отправка failed-отчёта;
* ручной resend из Email history;
* фиксируется как новый лог (не overwrite).

**Delivery SLA (опционально)**

* отчёт должен быть отправлен:

  * в течение X минут после completion job;
  * или по расписанию (weekly/monthly).
* нарушение delivery SLA — отдельный сигнал (не обязательно violation).

**Failure diagnostics**

* классификация ошибок:

  * invalid email;
  * SMTP / provider error;
  * временная недоступность.
* агрегированная статистика по failed deliveries.

---

### 2.6.6. Принципы V2 для Email history

1. **Email ≠ side-effect**

   * это управляемое и аудируемое действие.

2. **Append-only лог**

   * каждая отправка — отдельная запись;
   * никакого «перезаписали старое».

3. **Backend owns semantics**

   * фронт не интерпретирует статусы;
   * только отображает.

4. **Связь с Evidence**

   * email всегда связан с job или периодом;
   * не существует «просто письма».

---

### 2.6.7. Что осознанно НЕ делаем в V2

Чтобы сохранить фокус:

* ❌ массовые маркетинговые рассылки;
* ❌ кастомные email-шаблоны для каждого клиента;
* ❌ автоматические email-триггеры без явного правила;
* ❌ внешние email-кампании.

Email history в V2 — **операционная и доказательная коммуникация**, не маркетинг.

---

### Роль Email history в V2 (итог)

В V2 Email history:

* становится частью Evidence & Audit слоя;
* связывает execution → reports → коммуникацию;
* готовит платформу к enterprise-аудиту;
* масштабируется без ломки V1.

Это закрывает разрыв между
**“job выполнен”** и **“клиент получил доказательства”**.

---

## 3. Пилон V2.2 — SLA & Evidence v2

### 3.1. Цель

**Сделать Evidence-слой таким, чтобы он выдерживал:**

- спор с клиентом,
- внутреннюю проверку качества,
- рост числа job и пользователей.

### 3.2. Расширение типов SLA-нарушений (не ломая существующие)

Сейчас основные reasons связаны с proof (фото/чек-лист).

В V2 добавляем новые категории, например:

- `late_start` — job начата позже планового времени;
- `late_finish` — job завершена позже планового конца (с учётом политики);
- `frequent_cancellation` — высокий процент отмен в локации/по клинеру;
- `gps_mismatch_minor` / `gps_mismatch_major` — серьёзность отклонения.

#### Требования

- Каждому reason:
  - чёткое текстовое объяснение для владельца;
  - понятный mapping на события и поля:
    - `actual_start`, `actual_end`,
    - `scheduled_start`, `scheduled_end`,
    - GPS-координаты,
    - события отмены.

- Новые reasons добавляются **расширением**, а не изменением семантики старых.

---

### 3.3. Evidence timeline

#### Идея

Для каждой job хотим видеть **ленточку событий**:

- planned: `scheduled_start/end`;
- events:
  - check-in (время, координаты);
  - фото (before/after, кто сделал, когда, GPS);
  - checklist completed (кто, когда);
  - check-out / completed.

#### Зачем

- Это “история” job, которую можно показать:
  - владельцу,
  - клиенту,
  - внутреннему аудитору.
- Позволяет:
  - быстро понять, что реально происходило;
  - защищать доказательства в спорных ситуациях.

#### Требования к реализации

- Использовать уже существующий `JobCheckEvent` как основу:
  - при необходимости расширить типы событий;
  - **не плодить новые сущности без нужды**.
- UI:
  - компактный timeline в Job details;
  - опционально — развёрнутый Evidence view.


### 3.4. Checklist as Evidence & SLA Signal

#### Роль чеклиста в V2

В V2 чек-лист рассматривается **не как UI-форма**, а как:

* структурированное evidence выполнения работы;
* формализованный сигнал для SLA Engine;
* единая точка связи между Planning → Execution → Proof → SLA → Reports.

Checklist в V2 — это **объект с семантикой**, а не просто набор галочек.

---

#### Checklist и жизненный цикл job

Checklist:

* создаётся **на основе шаблона** при создании job;
* фиксируется как часть execution-слоя;
* имеет собственное состояние:

  * `pending` — job ещё не завершена;
  * `completed` — чек-лист полностью закрыт;
  * `not_completed` — job завершена, но чек-лист не закрыт.

Важно:
`pending` **не является нарушением SLA**.
`not_completed` **является прямым SLA-событием**.

---

#### Связь checklist с SLA Engine v2

Checklist влияет на SLA через универсальный reason code:

* `checklist_not_completed`

Но интерпретация этого reason зависит от **policy** и **контекста job**.

SLA Engine v2 должен учитывать:

1. **Статус job**

   * `scheduled` / `in_progress` → checklist = `pending` (OK);
   * `completed` + checklist = false → `checklist_not_completed`.

2. **Proof policy**

   * checklist может быть:

     * required;
     * optional;
     * disabled (для конкретной локации / типа job).
   * если checklist **не required**, его отсутствие не генерирует SLA violation.

3. **Источник нарушения**

   * checklist_not_completed всегда ссылается на:

     * конкретный job;
     * конкретный checklist;
     * конкретные пункты, которые не были закрыты.

Таким образом, SLA Engine опирается не на “факт отсутствия галочки”,
а на **валидированное правило политики + фактические данные execution**.

---

#### Checklist как часть Evidence

В Evidence-слое checklist используется как:

* часть timeline job (когда и кем был завершён);
* объяснение причины SLA violation;
* доказательство в отчётах для owner / клиента.

Checklist должен быть:

* доступен в Job Details / JobSidePanel;
* отображаем в Reports и PDF;
* связан с конкретным SLA reason без двусмысленностей.

---

#### Принцип расширяемости

V2 закладывает возможность:

* версионирования checklist-шаблонов;
* частичного выполнения чек-листа;
* расширения checklist в сторону:

  * обязательных / опциональных пунктов;
  * conditional items (опционально в будущих версиях).

При этом:

* существующий reason `checklist_not_completed` остаётся стабильным;
* новые типы логики добавляются **через policy**, а не через новые reason codes.

---

## Что это даёт стратегически

После этого блока:

* ✔ понятно, **почему checklist — часть SLA**, а не “ещё одна форма”;
* ✔ понятно, **как owner может доверять отчётам**;
* ✔ понятно, что V2 масштабируем:

  * разные политики,
  * разные типы job,
  * разные требования клиентов.

## Checklist customization (V2)
Checklist templates remain the primary unit of standardization and SLA.
Manual checklist composition is not allowed as a default flow.

V2 introduces controlled customization:
adding extra checklist items on top of a template;
disabling optional items when allowed by policy.

SLA evaluation is based on the effective checklist after overrides.
---

## 4. Пилон V2.3 — Reports & Analytics

### 4.1. Unified Analytics page

Сейчас:

- есть Reports (weekly/monthly);
- есть SLA Performance / Violations;
- задуман Analytics API v1 (семантика).

В V2 задача:

> Сделать единый **Analytics**-слой, который станет фактическим источником данных  
> для Reports, SLA Performance и новых графиков.

#### Структура будущей Analytics-страницы (пример)

- **Overview**
  - KPI за выбранный период:
    - jobs completed;
    - issue rate;
    - proof completion;
    - on-time completion;
    - issues detected.
- **Trends**
  - jobs completed over time;
  - average job duration;
  - proof completion trend (before/after/checklist).
- **Cleaners**
  - performance по клинерам;
  - таблица + простой график.
- **Locations**
  - аналогично, по локациям.

#### Связь с Analytics API v1

Analytics API:

- определяет **формат и семантику** данных;
- работает как единый слой для:
  - Analytics UI;
  - Reports (могут переехать на этот API);
  - SLA Performance (может переиспользовать часть агрегатов).

---

### 4.2. Custom periods & comparisons

Для V2 важно позволить менеджеру и владельцу смотреть:

- **произвольные периоды** (не только week/month),
- **сравнения**:
  - this month vs previous month;
  - this location vs company average;
  - этот клинер vs median.

Ограничения:

- делаем это **после** того, как базовый Analytics API и UI готовы;
- не перегружаем интерфейс — первые версии сравнения могут быть:
  - simple: “+X% vs previous period”,
  - без сложных графиков.

---

## 5. Пилон V2.4 — Commerce & Roles

### 5.1. План/тарифная модель

#### Цели

- Сформировать **коммерческий скелет**:
  - планы,
  - лимиты,
  - trial/paid-состояния.

#### Модель

Сущность `Plan` (или аналог):

- параметры:
  - `max_jobs_per_month` (или per период);
  - `max_locations`;
  - `max_cleaners`;
  - другие лимиты (по мере необходимости).
- флаги:
  - `is_trial`;
  - `is_default_for_new_company`.

Связь с `Company`:

- у компании ровно один активный план;
- есть информация о:
  - дате начала trial;
  - дате окончания trial (если есть);
  - статусе: active / trial_expired / suspended.

---

### 5.2. Enforcement лимитов

V2 не обязан сразу блокировать всё “в лоб”:

- первый шаг — **soft enforcement**:
  - предупреждения в UI;
  - явные сообщения при попытке выйти за лимит.

Возможные сценарии:

- компания превысила `max_jobs_per_month`:
  - блокируем создание новых jobs;
  - показываем понятное сообщение;
  - даём ссылку на Billing/Plans страницу.

Все правила enforcement должны быть:

- задокументированы в `API_CONTRACTS.md` и `MASTER_BRIEF.md`;
- реализованы **на backend**, UI только показывает сообщения.

---

### 5.3. Multi-role access

#### Цель

Отделить:

- **owner** — стратегический взгляд, финансы, общий SLA;
- **manager** — операционное управление job’ами;
- **supervisor** — локальный контроль локации/команды;
- **cleaner** — ограниченный доступ (свой график, своя история).

V2:

- не обязательно сразу реализовывать все роли,
- важно **заложить модель**, где:
  - права завязаны на роль + company;
  - каждый endpoint знает, кому он доступен.

---

## 6. Пилон V2.5 — Platform & Security

### 6.1. Audit & экспорт

#### Audit

Уже есть:

- `JobCheckEvent`;
- `ReportEmailLog`.

В V2:

- формализовать, какие действия считаются **аудируемыми**:
  - изменение статуса job;
  - override SLA;
  - ручная правка времени выполнения;
  - смена планов/лимитов.

Для этих действий:

- обязателен trace:
  - кто,
  - когда,
  - что именно изменил.

#### Экспорт

- Минимум: CSV / JSON-экспорт ключевых отчётов для owner-level:
  - jobs + SLA flags;
  - aggregated SLA per period;
  - proof-completion статистика.

---

### 6.2. API versioning & stability

#### Принципы

- `v1` — всё, что уже есть сейчас;
- V2-изменения:
  - по возможности backward-compatible;
  - если breaking — явная пометка v2.

Примеры правил:

- можно добавлять новые поля в ответы v1;
- нельзя:
  - менять семантику существующих полей;
  - удалять обязательные поля.

Если требуется серьёзный пересмотр — создаём:

- новый endpoint (`/v2/...` или `.../v2/`);
- новую секцию в `API_CONTRACTS.md` с пометкой v2.

---

## 7. Что НЕ входит в V2 (осознанно)

Чтобы не размазать фокус, явно фиксируем, чего **нет** в V2:

- ❌ marketplace клинеров (агрегатор чужих подрядчиков);
- ❌ “no-code workflow builder” для собственных сценариев;
- ❌ “AI ради AI”:
  - автогенерация отчётов без понятных исходных метрик;
  - “smart suggestions”, не подкреплённые фактами;
- ❌ real-time streaming dashboards:
  - V2 достаточно обновления по запросу / периодически.

Эти темы — либо V3, либо отдельный продукт.

---

## 8. Как использовать этот документ

1. **Для PRD:**  
   - по каждому пилону (Execution / SLA / Analytics / Commerce / Platform)
     собирать отдельный PRD, ссылаясь на соответствующие разделы этого файла.

2. **Для планирования:**  
   - приоритизировать:
     - сначала V2.1 (Execution & Mobile),
     - затем V2.4 (Commerce skeleton),
     - потом V2.3 (Analytics реализация),
     - параллельно — точечные улучшения SLA & Evidence.

3. **Для общения с разработчиками / партнёрами:**  
   - показывать как “источник правды” по тому, что вообще включено в V2,
     а что точно **не делаем** на этом этапе.

---
